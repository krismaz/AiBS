\section{Methods}

We have implemented two algorithms: Global Linear Alignment and Global Affine Alignment. 

Our implementation is done in Python3, using the Numpy library for handling tables, and the BioPy library for parsing FASTA-files.
Everything was implemented using the pseudo-code from the slides from the lecture. 

The algorithms operate on strings (instead of alternatives like arrays or lists). They use a row by row approach as opposed to recursive memoization. 
When we use affine backtracking we alternate between row and column, to ensure linear backtracking performance. 

\subsection{Running}

To run the program, \verb|python3| with the packages \verb|numpy| and
\verb|biopython| needs to be installed. On a Ubunto based system, this can
be achieved by running:

\verb|sudo apt-get install python3 python3-dev python3-setuptools|

\verb|sudo easy_install3 numpy biopython|

In a linux shell, the answers to question one through four can then be
generated by running

\verb|./eval.sh|

\paragraph{}
In general, the code can be run with

\begin{verbatim}
python3 exc2test.py <cost_file> <fasta_file> <seq1_name> <seq2_name>
 [--backtrack] [--affine] [--matrix]
\end{verbatim}

where

\begin{description}
\item{\verb|cost_file|:} A file like \verb|exc2.cost|, where the
  first line is the alphabet and the rest og the file is a cost-matrix
  (rows seperated by ; and otherwise just whitespace seperated).
\item{\verb|fasta_file|:} A file like \verb|exc2.fasta|, which is just
  a \verb|FASTA| file.
\item{\verb|seq1_name| and \verb|seq2_name|:} The names of the two
  sequenses to use from \verb|fasta_file|.
\item{\verb|--backtrack|:} Specifies that the algorithm should
  backtrack, i.e. actually print the alignment instead of just the
  score.
\item{\verb|--affine|:} Specifies that affine gap cost should be used.
\item{\verb|--matrix|:} Ignore \verb|seq1_name|, \verb|seq2_name| and
  \verb|--backtrack| and output a matrix of scores for every
  combination of sequences in \verb|fasta_file|.
\end{description}
